<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-gb">
<head>
  <title>LuaSNMP - SNMP Access</title>
  <link media="screen" href="style.css" rel="stylesheet" type="text/css" />
  <link media="print" rel="stylesheet" href="styleprint.css" type="text/css" />
</head>

<body>

























<div style="top: 12px; height: 129px; left: 0px; text-align: center; width: 925px;" id="logo"><a name="home2"></a><a href="http://www.lua.org"><img style="border: 0px solid ; left: 0px; top: 6px; width: 115px; height: 118px; float: left;" id="lualogo" alt="www.lua.org" src="luasnmp2.png" hspace="20" /></a></div>

























<div id="header">
<h1 style="height: 120px; margin-left: 0px; width: 928px;"><big><big><a name="home"></a><br />

























LuaSNMP - Reference</big></big> <br />

























Simple
Network Management Access with Lua</h1>

























</div>

























<div id="leftnavigation">
<ul>

























  <li style="margin-left: 0px; width: 185px;"><a class="current" href="index.html">Home</a> </li>

























  <li><a href="index.html#license">License</a></li>

























  <li><a href="index.html#features">Features</a></li>

























  <li><a href="index.html#download">Download</a></li>

























  <li><a href="index.html#installation">Installation</a></li>

























  <li><a href="running.html">MANUAL</a></li>

























  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <ul>

























    <li><a href="running.html">Running&nbsp;</a></li>

























    <li><a href="objects.html">Object Names</a></li>

























    <li><a href="objects.html#data_types">Data Types</a></li>

























    <li><a href="objects.html#varbinds">Varbinds</a></li>

























    <li><a href="objects.html#sessions">SNMP Sessions</a></li>

























    <li><a href="objects.html#trap_handling">Trap Handling</a></li>

























    <li><a href="mib.html">Access to MIBs</a></li>

























    <li><a href="snmp.html">Access to SNMP</a></li>

























    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <ul>

























      <li><a href="#snmp_open">snmp.open</a></li>

























      <li><a href="#snmp_clone">snmp.clone</a></li>

























      <li><a href="#snmp_getversion">snmp.getversion</a></li>

























      <li><a href="#snmp_gettrapd">snmp.gettrapd</a></li>

























      <li><a href="#snmp_close">snmp.close</a></li>

























      <li><a href="#snmp_get">snmp.get</a></li>

























      <li><a href="#snmp_async_get">snmp.asynch_get</a></li>

























      <li><a href="#snmp_getnext">snmp.getnext</a></li>

























      <li><a href="#snmp_asynch_getnext">snmp.as</a><a href="#snmp_asynch_getnext">ync</a><a href="#snmp_asynch_getnext">h_getnext</a></li>

























      <li><a href="#snmp_set">snmp.set</a></li>

























      <li><a href="#snmp_asynch_set">snmp.as</a><a href="#snmp_asynch_set">ync</a><a href="#Lorem">h_set</a></li>

























      <li><a href="#snmp_getbulk">snmp.getbulk</a></li>

























      <li><a href="#snmp_asynch_getbulk">snmp.as</a><a href="#snmp_asynch_getbulk">ync</a><a href="#Lorem">h_getbulk</a></li>

























      <li><a href="#snmp_walk">snmp.walk</a></li>

























      <li><a href="#snmp_inform">snmp.inform</a></li>

























      <li><a href="#snmp_asynch_inform">snmp.as</a><a href="#snmp_asynch_inform">ync</a><a href="#Lorem">h_inform</a></li>

























      <li><a href="#snmp_wait">snmp.wait</a></li>

























      <li><a href="#snmp_loop">snmp.idle</a></li>

























      <li><a href="#snmp_loop">snmp.loop</a></li>

























      <li><a href="#snmp_event">snmp.event</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    </ul>













    <li><a href="#user_mgmt">SNMPv3 User Mgmt (USM)</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    <ul>













      <li><a href="#snmp_createuser">snmp.createuser</a></li>













      <li><a href="#snmp_clonefrom">snmp.clonefromeuser</a></li>












      <li><a href="#snmp_deteleuser">snmp.deleteuser</a></li>













      <li><a href="#snmp_newpassword">snmp.newpassword</a></li>












      <li><a href="#snmp_createkey">snmp.createkey</a></li>












      <li><a href="#snmp_createlocalkey">snmp.createlocalkey</a></li>












      <li><a href="#snmp_keychange">snmp.keychange</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    </ul>













    <li><a href="#vacm">View Base Acecess (VACM)</a></li>






    
    
    
    
    
    
    <ul>






      <li><a href="#vacm_sec2group">snmp.createsectogroup</a></li>






      <li><a href="#vacm_delete_sec2group">snmp.deletesectogroup</a></li>






      <li><a href="#vacm_createview">snmp.createview</a></li>






      <li><a href="#vacm_delete_view">snmp.deleteview</a></li>






      <li><a href="#vacm_createaccess">snmp.createaccess</a></li>






      <li><a href="#vacm_delete_access">snmp.deleteaccess</a></li>






    
    
    
    
    
    
    </ul>






    <li><a href="#data_conversion">Data Conversion</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    <ul>




















      <li><a href="#snmp_newvar">snmp.newvar</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    </ul>













    
    
    
    
    
    
    
    
    
    
    
    
    
    <ul>

























      <li><a href="#snmp_sprintvar">snmp.sprintvar</a></li>



















      <li><a href="#snmp_sprintvar">snmp.sprintvar2</a></li>

























      <li><a href="#snmp_sprintval">snmp.sprintval</a></li>



















      <li><a href="#snmp_sprintval">snmp.sprintval2</a></li>

























      <li><a href="#snmp_sprinttype">snmp.sprinttype</a></li>













      <li><a href="#snmp_sprintkey">snmp.sprintkey</a></li>













      <li><a href="#snmp_sprintkeyx">snmp.sprintkeyx</a></li>













      <li><a href="#snmp_sprintkeyd">snmp.sprintkeyd</a></li>



















      <li><a href="#snmp_uptimev2s">snmp.uptimeS2V</a></li>



















      <li><a href="#snmp_uptimev2s">snmp.uptimeV2S</a></li>













      <li><a href="#snmp_sprintkeyd">snmp.key2oid</a></li>













      <li><a href="#snmp_sprintkeyx">snmp.key2hex</a></li>













      <li><a href="#snmp_sprintkey">snmp.key2octet</a></li>







      <li><a href="#snmp_sprintkey">snmp.octetstring</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    </ul>













    <li><a href="#exceptions">Finalized Exceptions</a></li>



    
    
    
    <ul>



      <li><a href="#snmp_protect">snmp.protect</a></li>



      <li><a href="#snmp_newtry">snmp.newtry</a></li>



      <li><a href="#snmp_try">snmp.try</a></li>



    
    
    
    </ul>



    <li><a href="#misc_func">Misc. Functions</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    <ul>














      <li><a href="#snmp_check">snmp.check</a></li>











      <li><a href="#snmp_getkeys">snmp.getkeys</a></li>














      <li><a href="#snmp_spairs">snmp.spairs</a></li>









      <li><a href="#snmp_instance">snmp.instance</a></li>







      <li><a href="#snmp_instance">snmp.stringoid</a></li>

























      











    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    </ul>













    
    
    
    
    
    
    
    
    
    
    
    
    
    <ul>













      <li><a href="#snmp_object_access">SNMP Object Access</a></li>













    
    
    
    
    
    
    
    
    
    
    
    
    
    </ul>

























    <li><a href="examples.html">Examples</a> </li>

























  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  </ul>

























  <li><a href="index.html#whatsnew">What's New</a></li>

























  <li><a href="index.html#credits">Credits</a></li>

























  <li><a href="index.html#links">Links</a></li>

























  <li><a href="index.html#todo">ToDo</a></li>

























</ul>

























</div>

























<div id="content">
<h1>Access to SNMP</h1>







<p>This is the core part of LuaSNMP. It provides routines for the following purposes:</p>






<ul>






  <li>Open, clone and close SNMP sessions to&nbsp;remote device</li>






  <li>SNMP set, get, getnext, getbulk and walk primitives for synchronous and asynchronous operation</li>






  <li>Event handling for asynchronous SNMP requests: event loop, single event capture</li>






  <li>SNMP version 3 user management (USM): create, clone, delete users, change passwords</li>






  <li>SNMP view based access methods (VACM) management: map security
names to security groups, create/delete views, create /
delete&nbsp;access rights based on groups an views.</li>






  <li>Data conversion between Lua and SNMP types.</li>






  <li>OID and instance generation from basic Lua&nbsp; types.</li>






  <li>Varbind and varbind list creation, concatenation, etc.</li>






  <li>Miscellaneous &nbsp;helper functions, like result checking, sorting interator function</li>






  <li>more ...</li>






</ul>







<h4><a name="snmp_open"></a>session, err =
snmp.open([CONFIG])</h4>

























<p>The Function <i style="font-weight: bold; font-style: italic;">snmp.open</i><span style="font-weight: bold; font-style: italic;"> </span>is
used for creating, or opening, <a href="objects.html#sessions" target="content">SNMP sessions</a>. It is a Lua<i>
constructor</i>
that validates the provided session configuration parameters given as a
Lua table <span style="font-weight: bold;">CONFIG</span>,
creates a
Lua table for storing them, and allocates resources for controlling the
SNMP operations invoked for the session. Default values are used when
one, or more, configuration parameters are omitted.</p>

























<p>Default values are provided by the following sources with the
stated precedence:</p>

























<ol>

























  <li>Given CONFIG table</li>

























  <li>Net-SNMP configuration files snmp.conf (see snmp.conf(5)
manual page for details)</li>

























  <li>LuaSNMP default values</li>

























</ol>

























<p>Lua SNMP default values:</p>

























<ul>

























  <li>version = SNMPv2c</li>

























  <li>community = "public"</li>

























  <li>timeout = 1</li>

























  <li>retries = 5</li>

























  <li>port = 161</li>

























  <li>includeroot = false</li>

























  <li>peer = "0.0.0.0"</li>

























</ul>

























<p>All other unconfigured parameters are either set to nil or
have no meaning for a version 2 session.</p>

























<p>If a new
Shttp://lua-users.org/lists/lua-l/http://lua-users.org/lists/lua-l/http://lua-users.org/lists/lua-l/NMP
session is successfully created, <i><span style="font-weight: bold;">snmp.open</span> </i>returns
a reference to this session. The
returned reference must be specified as a handle in all invocations of
SNMP
operations for the session.</p>

























<p>If the provided configuration is invalid or an Net-SNMP
internal error occurs, no session is created. In this case, <i><span style="font-weight: bold;">snmp.open&nbsp;</span> </i>returns
<b>nil </b>plus an <span style="font-weight: bold;">error
message.</span></p>

























<p>Note, that all SNMP set and get functions are also mapped to a
successfully created session, which allows to perform SNMP requests as
a direct method call to a session. See also below.</p>

























<p>The following example illustrates the creation of an SNMP
session
that can be used by a management application for invoking SNMP
operations on the agent identified by its host name&nbsp;<span style="font-style: italic;">"goofy"</span>. All
SNMP messages sent to the agent will use the community string <span style="font-style: italic;">"private"</span>.&nbsp;
SNMP version 2c (default value). A user-defined
function&nbsp;<span style="font-style: italic;">trap_cb</span>
will be called whenever an SNMP trap originated by this agent is
received. Another user defined function <span style="font-style: italic;">default_cb</span> is called for asynchronous requests (see <a style="font-style: italic;" href="#snmp_async_get">snmp.asynch_get</a>) </p>

























<pre>hub1, err = snmp.open{<br />  peer = "goofy", <br />  community = "private", <br />  trap = trap_cb,<br />  callback = default_cb,<br />}<br />assert(hub1, err)</pre>






















<h4><a name="snmp_clone"></a>session, err =
snmp.clone(PARENT [, CONFIG])<br />






















session, err = PARENT:clone([CONFIG])</h4>






















<p>Clones a valid session. The new session inherits all
configuration parameters from it's parent session <span style="font-weight: bold;">PARENT</span>. If a
configuration table CONFIG is provided, this configuration table
overrides the parent's configuration.</p>

























<p>After successful creation the new session is completely
independent from the parent session. In case of an error, the function <span style="font-style: italic; font-weight: bold;">snmp.clone </span><span style="font-style: italic;"></span>returns <span style="font-weight: bold;">nil</span> and an <span style="font-weight: bold;">error message</span>.</p>

























<pre>hub2, err = snmp.clone(hub1, {peer = "localhost"})<br />assert(hub2, err)<br />-- or simpler<br />hub2, err = hub1:clone{peer = "localhost"}<br />-- or event simpler including error handling<br />hub2 = assert(hub1:clone{peer = "localhost"})<br /></pre>

























<h4><a name="snmp_getversion"></a>retval =
snmp.getversion(SESSION)&nbsp;<br />

























retval =&nbsp;SESSION:getversion()</h4>

























<p>Returns the SNMP version of the given SESSION as string. If
the
session does not exist or does not own a valid valid version
configuration parameter, the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>.</p>

























<h4><a name="snmp_gettrapd"></a>retval =
snmp.gettrapd()</h4>

























<p>Returns a string with the name of the trapdaemon for which
LuaSNMP
has been configured during compile time. The string contains either
"straps" or "snmptrapd" (default).</p>

























<h4><a name="snmp_close"></a>err =
snmp.close(SESSION)<br />

























err = SESSION:close()</h4>

























<p>Terminates an active SNMP session. The function receives the <span style="font-weight: bold;">SESSION </span>previously
created by snmp.open or snmp.close as handle<span style="font-weight: bold;">.</span> The function
returns <span style="font-weight: bold;">1 </span>on success. In case of an error the function returns an <span style="font-weight: bold;">nil </span>plus an<span style="font-weight: bold;"> </span><span style="font-weight: bold;">error message</span>.</p>

























<p>In the following example, the SNMP session previously
described is terminated.</p>

























<pre>-- Form 1<br />err = snmp.close(hub1)<br />-- Simplified form:<br />err = hub1:close()</pre>

























<p><span style="font-weight: bold;">NOTE: </span>If
the sssion that
shall be closed is waiting for an asynchronous request (either get or
set) to complete, the session is not immediately closed, but put into a
queue and will be closed once the request has completed. Any associated
callback function (either default or request specific) is called before
the session is actually closed and all it's data is garbage collected.</p>

























<p>Error codes returned by <span style="font-weight: bold; font-style: italic;">snmp.close</span>&nbsp; can be
safely&nbsp;discarded.</p>

























<h4><a name="snmp_get"></a>varbind, err,
errindex = snmp.get(SESSION, VARS)<br />

























varbind, err, errindex = SESSION:get(VARS)<br />

























</h4>



























<p>The function <i><span style="font-weight: bold;">snmp.get&nbsp;</span> </i>is&nbsp;used to perform SNMP<i> get </i>operations
for the specified <span style="font-weight: bold;">SESSION</span>. One or more MIB variable instances can be retieved by a single call.&nbsp;</p>

























<p>While <i style="font-weight: bold;">snmp.get &nbsp;</i>performs a&nbsp;<span style="font-style: italic;">synchronous</span> get operation which&nbsp;returns only when
the operation completes,&nbsp; the function <a href="#snmp_async_get"><i style="font-weight: bold;">snmp.asynch_get</i></a>
(see below) operates asynchronous and returns immediately to the caller.&nbsp;</p>

























<p>The first argument <span style="font-weight: bold;">SESSION</span>&nbsp;is a reference to an SNMP session, returned from a previous call to <a href="#snmp_open" target="content"><i>snmp.open</i></a>
or <a href="#snmp_clone"><span style="font-style: italic;">snmp.clone</span></a>.
The second argument <span style="font-weight: bold;">VARS</span>
identifies the MIB variable instance(s) to be retrieved.</p>
























<p>
A <span style="font-weight: bold;">single MIB variable</span> instance can be identified by:</p>

























<p>
A string containing either an object identifier (OID in dotted
notation) or the name of the variable to be retrieved. Notice that an
instance identifier must always be specified. As an example, both
strings "sysName.0" and "1.3.6.1.2.1.1.4.0" can be used for retrieving
the current value of the MIB-II variable sysName.
</p>

























<ul>

























  <li>a <i style="font-weight: bold;">varbind table</i>,
as&nbsp; described in section&nbsp;<a href="objects.html#varbinds" target="content">Varbinds</a>.
Notice that the attributes <i>type </i>and <i>value</i>
can be omitted. As an example, both <i>varbind tables</i> <code>{oid="sysName.0"}</code>
and <code>{oid="1.3.6.1.2.1.1.4.0"}</code> can be used for
retrieving the current value of the MIB-II variable <i>sysName</i>.</li>

























</ul>

























<p>A <span style="font-weight: bold;">list of MIB
variable instances</span> to be retrieved can be identified by:</p>

























<ul>

























  <li>a list (table) of <i>strings</i> as described
above, like <code>{"sysName.0","sysLocation.0","1.3.6.1.2.1.1.5.0"}</code>
  </li>

























  <li>a <i>varbind list</i>, like <code>{{oid="sysName.0"},{oid="sysLocation.0"},{oid="1.3.6.1.2.1.1.5.0"}}</code></li>

























</ul>



























<p><span style="font-style: italic; font-weight: bold;">snmp.get &nbsp;</span>returns&nbsp;a <i style="font-weight: bold;">varbind table</i>&nbsp;or a <i style="font-weight: bold;">varbind
list</i>, if the operation completes successfully.&nbsp;In case of&nbsp;errors <span style="font-style: italic;">detected locally</span> the function returns nil plus an error message. In case of errors <span style="font-style: italic;">detected by the agent</span> the returned varbind list&nbsp;may be empty<span style="font-weight: bold;"> </span>or may contain less values as requested, if one or more values
couldn't be retrieved by the agent. Two additional values are then returned: a
string containing the <span style="font-weight: bold;">error
message</span> and an <span style="font-weight: bold;">error
index</span> indicating the first instance that couldn't be
retrieved.<br />

























</p>

























<p>If a varbind list is returned, each element of this varbind
list is a fully specified varbind table.
Please notice that the oid<span style="font-style: italic;"> </span>attributes in the varbind
tables returned by <i style="font-weight: bold;">snmp.get&nbsp;</i> always
contain object identifiers in dotted notation.</p>

























<p>The following example illustrates the use of <i style="font-weight: bold;">snmp.get</i><span style="font-weight: bold; font-style: italic;">&nbsp;</span> for retrieving
the values of some of the variables in the <i>system</i>
group of MIB-II:</p>

























<pre>vlist, err, index = snmp.get(hub1, {"sysName.0","sysContact.0"}) <br />if not err then <br /> print(string.format("Contact for %s : %s", <br />                     vlist[1].value, vlist[2].value)) <br />else <br />  if index then <br />    print(string.format("Error : %s in index %d", err, index)) <br />  else <br />    print(string.format("Error : %s", err)) <br />  end <br />end<br /></pre>























<p>For convenience, LuaSNMP provides a means to perform SNMP requests in form of a <span style="font-weight: bold;">method call</span> to a valid session:</p>























<pre>-- Request single varbind<br />vbind, err = hub1:get("sysContact.0")<br /><br />-- Request list of varbinds<br />vlist, err, index = hub1:get{"sysName.0","sysContact.0"}<br />...</pre>























<h4><a name="snmp_async_get"></a>reqid, err =
snmp.asynch_get(SESSION, VARS [,CALLBACK [,MAGIC]])<br />

























reqid, err = SESSION:asynch_get(VARS [,CALLBACK [,MAGIC]])</h4>























<p>The function <span style="font-style: italic; font-weight: bold;">snmp.asynch_get&nbsp;</span> performs the same operation as
<a href="#snmp_get"><span style="font-style: italic;">snmp.get</span></a>. However, instead of waiting for the request to complete, the
function&nbsp;returns immediately after sending a <i>get-request</i>
message to the agent. When this request completes,&nbsp; a user-defined <span style="font-weight: bold;">CALLBACK</span> function
is&nbsp;invoked.&nbsp;</p>























<p>The&nbsp; <span style="font-weight: bold;">CALLBACK</span> argument is optional. When
present, it specifies a user-defined callback
function to be invoked when the asynchronous operation completes. When
this argument is omitted, the default callback
function, specified when the SNMP session is created, is used.</p>























<p>Each asynchronous operation can be associated with an opaque value <span style="font-weight: bold;">MAGIC</span>,
which is transparently transported to the callback function. Note, that
you can define a request specific magic value even if the request
utilises the session's default callback function.</p>























<p><b style="font-style: italic;">snmp.asynch_get&nbsp;</b><span style="font-style: italic;"> </span>returns a <span style="font-weight: bold;">number </span>containing the<i> </i>request id, if the request&nbsp;started successfully. If not, the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>.</p>























<p>When the <i>get</i> operation completes, the
user-defined <span style="font-weight: bold;">CALLBACK</span> function is invoked,
receiving up to&nbsp; 6 arguments. The first three arguments are similar to
the values returned from <i>snmp.get</i>: a <span style="font-weight: bold;">varbind
table</span> (or a <span style="font-weight: bold;">varbind list</span>), a <span style="font-weight: bold;">string</span> containint the <span style="font-weight: bold;">error
status</span> or <span style="font-weight: bold;">nil</span>, and an <span style="font-weight: bold;">error index</span>, if an error occurred.
The fourth argument is a number with the <i style="font-weight: bold;">request-id</i><span style="font-weight: bold;"> </span>associated to
the completed
asynchronous request. The fifth&nbsp; argument contains a <span style="font-weight: bold;">reference to the
SNMP session</span>. The last argument is the opaque magic value, which can be of any type.&nbsp;</p>





















<p>If no response is received, LuaSNMP performs the configured number
of retries for the request. If none of these retries succeeds, the
callback function is called with an error status indicating a timeout.
</p>

























<p>The following example illustrates the use of <i style="font-weight: bold;">snmp.asynch_get</i><span style="font-style: italic; font-weight: bold;">&nbsp;</span>
in a very simple
application. In this example, we assume that function <i>poll</i>
is called periodically. Based on
a list of records that describes a group of SNMP agents (the Lua table <i>agents</i>),
function <i>poll</i> invokes asynchronous <i>get</i>
operations for testing these agents' current status. Another Lua table (<i>polled</i>)
maintains associations between pending requests and agents. The <i>callback</i>
function <i>poll_cb</i> is invoked when an asynchronous
request is completed. For simplicity,
error conditions are mostly ignored.
</p>

























<pre>local snmp = require "snmp"<br /><br />polled = {}<br />local count = 3<br /><br />local function poll_cb(vb, err, index, reqid, session, magic)<br />  local agent = polled[reqid]<br />  polled[reqid] = nil<br />  if vb then<br />    agent.status = "alive"<br />  else<br />    if err == "snmp: timeout"  then<br />      agent.status = "no response"<br />    else<br />      agent.status = "?"<br />    end<br />  end<br />  count = count - 1<br />end<br /><br />function poll(agents)<br />  local i, agent = next(agents,nil)<br />  while i do<br />    local reqid = snmp.asynch_get(agent.session, <br />	                          "sysUpTime.0", poll_cb)<br />    if reqid then<br />      polled[reqid] = agent<br />    end<br />    i, agent = next(agents,i)<br />  end<br />end<br /><br />local agents = {<br />  { session = snmp.open{peer = "goofy"}, name = "goofy" },  <br />  { session = snmp.open{peer = "192.168.99.1"}, name = "192.168.99.1"},  <br />  { session = snmp.open{peer = "localhost"}, name = "localhost" }<br />}<br /><br /><br />poll(agents)<br />while count &gt; 0 do <br />  snmp.event()<br />end<br /><br />for _, agent in ipairs(agents) do<br />  print(string.format("Agent status of %s: %s", <br />                      agent.name, agent.status or 'failure'))<br />  agent.session:close()<br />end<br /></pre>





















<p>Since only the first value returned by <i style="font-weight: bold;">snmp.asynch_get&nbsp;</i><span style="font-weight: bold;"> </span>is necessary (the request-id),
the remaining values can be&nbsp; discarded. Lua adjusts the list of returned
values at run-time. Lua also dynamically adjusts the list of arguments
when a function is called. As the <i>session</i>,&nbsp; <i>index</i>
and <span style="font-style: italic;">magic</span> arguments of the callback function are not used in this implementation,
the definition of <i>poll_cb</i> could be simplified to:
</p>

























<pre>function poll_cb(vb, err, _, reqid)<br />  ...<br />end</pre>





















<h4><a name="snmp_getnext"></a>varbind, err,
errindex = snmp.getnext(SESSION, VARS)<br />

























varbind, err, errindex = SESSION:getnext(VARS)</h4>





















<p>The function <i style="font-weight: bold;">snmp.getnext&nbsp; </i>is used to perform SNMP<i> get-next </i>operations
for the specified session. It&nbsp;retrieves the values of the lexicographical successors
of a list of MIB objects.</p>





















<p>While&nbsp;<i style="font-weight: bold;">snmp.getnext</i><span style="font-style: italic; font-weight: bold;">&nbsp;</span> performs a&nbsp;<span style="font-style: italic;">synchronous</span> get-next operation, which returns only when the operation completes, the function <a href="snmp_asynch_getnext"><i style="font-weight: bold;">snmp.asynch_getnext</i></a> operates asynchronously and returns immediately to the caller.</p>





















<p>The first argument <span style="font-weight: bold;">SESSION</span> is a reference to a valid SNMP session.
The second argument <span style="font-weight: bold;">VARS</span> identifies one or more MIB <i>objects</i>. MIB objects are identified as described
for <a href="#snmp_get" target="content"><i>snmp.get</i></a>. A single object is identified by a <i style="font-weight: bold;">string</i><span style="font-weight: bold;">
</span>or by a <i style="font-weight: bold;">varbind table</i>, containing either an <i>object identifier</i> or a <i>MIB label</i>,
like <code>"1.3.6.1.2.1.1"</code> or <code>"system"</code>. 
Note that instance identifiers are not necessary.
A list of objects is identified by a <span style="font-weight: bold;">list of strings</span> or by a <i style="font-weight: bold;">varbind list</i>.</p>




















<p><b style="font-style: italic;">snmp.getnext</b><span style="font-style: italic; font-weight: bold;">&nbsp;</span> returns&nbsp;a <i style="font-weight: bold;">varbind table</i> &nbsp;or a <i style="font-weight: bold;">varbind list</i>, if the operation completes successfully. In case of&nbsp;errors <span style="font-style: italic;">detected locally</span> the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>. In case of errors <span style="font-style: italic;">detected by the agent</span> the returned varbind list&nbsp;may be empty<span style="font-weight: bold;"> </span>or may contain less values as requested, if one or more values
couldn't be retrieved by the agent. Two additional values are then returned: a
string containing the <span style="font-weight: bold;">error
message</span> and an <span style="font-weight: bold;">error
index</span> indicating the first instance that couldn't be
retrieved.</p>





















<p>If a varbind list is returned, each element of this varbind
list is a fully specified varbind table.
Please notice that the oid<span style="font-style: italic;"> </span>attributes in the varbind
tables returned by <i style="font-weight: bold;">snmp.getnext</i><span style="font-style: italic; font-weight: bold;">&nbsp;</span> always
contain object identifiers in dotted notation.</p>




















<p>The following example illustrates the use of <i style="font-weight: bold;">snmp.getnext&nbsp; </i>for retrieving the whole MIB tree 
implemented by an agent. </p>





















<pre>require "snmp"<br />hub1 = assert(snmp.open{peer = "goofy"})<br />repeat<br />  vb, err = snmp.getnext (hub1, vb or {oid = "1"})<br />  if not err and vb.type ~= snmp.ENDOFMIBVIEW then<br />    print(snmp.sprintvar(vb))<br />  end<br />until vb.type == snmp.ENDOFMIBVIEW</pre>




















<h4><a name="snmp_asynch_getnext"></a>reqid, err = snmp.asynch_getnext(SESSION, VARS, [,CALLBACK [,MAGIC]])<br />

























reqid, err = SESSION:asynch_getnext(VARS [,CALLBACK [, MAGIC]])</h4>




















<p>The function <span style="font-weight: bold; font-style: italic;">snmp.asynch_getnext</span><span style="font-weight: bold;">&nbsp;</span> performs the same operation as
<a href="#snmp_getnext"><span style="font-style: italic;">snmp.getnext </span></a>. However, instead of waiting for the request to complete, the
function&nbsp;returns immediately aft<span style="font-style: italic;"></span>er sending a <i>getnext-request</i>
message to the agent. When this request completes,&nbsp; a user-defined <span style="font-weight: bold;">CALLBACK</span> function
is&nbsp;invoked.&nbsp;</p>




















<p>The&nbsp; <span style="font-weight: bold;">CALLBACK</span> argument is optional. When
present, it specifies a user-defined callback
function to be invoked when the asynchronous operation completes. When
this argument is omitted, the default callback
function, specified when the SNMP session is created, is used.</p>























<p>Each asynchronous operation can be associated with an opaque value <span style="font-weight: bold;">MAGIC</span>,
which is transparently transported to the callback function. Note, that
you can define a request specific magic value even if the request
utilises the session's default callback function.<b style="font-style: italic;"></b></p>




















<p><b style="font-style: italic;">snmp.asynch_getnext</b><span style="font-style: italic;"><span style="font-weight: bold;">&nbsp;</span> </span>returns a <span style="font-weight: bold;">number </span>containing the<i> </i>request id, if the request&nbsp;started successfully. If not, the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>.</p>























<p>When the <i>get</i> operation completes, the
user-defined <span style="font-weight: bold;">CALLBACK</span> function is invoked,
receiving up to&nbsp; 6 arguments. The first three arguments are similar to
the values returned from <i>snmp.get</i>: a <span style="font-weight: bold;">varbind
table</span> (or a <span style="font-weight: bold;">varbind list</span>), a <span style="font-weight: bold;">string</span> containint the <span style="font-weight: bold;">error
status</span> or <span style="font-weight: bold;">nil</span>, and an <span style="font-weight: bold;">error index</span>, if an error occurred.
The fourth argument is a number with the <i style="font-weight: bold;">request-id</i><span style="font-weight: bold;"> </span>associated to
the completed
asynchronous request. The fifth&nbsp; argument contains a <span style="font-weight: bold;">reference to the
SNMP session</span>. The last argument is the opaque magic value, which can be of any type.&nbsp;</p>




















<p>If no response is received, LuaSNMP performs the configured number
of retries for the request. If none of these retries succeeds, the
callback function is called with an error status indicating a timeout.</p>




















<p>The following example illustrates an asynchronous version of the MIB traversal shown above.&nbsp;
</p>




















<pre>require "snmp"<br /><br />local count = 0<br /><br />hub1 = assert(snmp.open{peer = "goofy"})<br /><br />function next_cb(vb, err, _, _, session)<br />  if not err and vb.type ~= snmp.ENDOFMIBVIEW then<br />    count = count + 1<br />    print(snmp.sprintvar(vb))<br />    session:asynch_getnext(vb, next_cb)<br />  else<br />    print(string.format("%d object instances retrieved", count))<br />    os.exit(0)<br />  end<br />end<br /><br />-- First call initialises retrieval of complete tree.<br />hub1:asynch_getnext("1", next_cb)<br />snmp.loop()<br /></pre>




















<h4><a name="snmp_set"></a>varbind, err,
errindex = snmp.set(SESSION, VARBIND | VARLIST)<br />

























varbind, err, errindex = SESSION:set(VARBIND | VARLIST)</h4>




















<p>The function <i><span style="font-weight: bold;">snmp.set&nbsp;</span> </i>is&nbsp;used to perform SNMP<i> set </i>operations
for the specified <span style="font-weight: bold;">SESSION</span>. One or more MIB variable instances can be modified by a single call.&nbsp;</p>


























<p>While <i style="font-weight: bold;">snmp.set</i><span style="font-style: italic; font-weight: bold;">&nbsp;</span>
performs a&nbsp;<span style="font-style: italic;">synchronous</span> set operation which&nbsp;returns only when
the operation completes,&nbsp; the function <a href="snmp.html#snmp_async_get"><i style="font-weight: bold;">snmp.asynch_set</i></a>
(see below) operates asynchronous and returns immediately to the caller.&nbsp;</p>


























<p>The first argument <span style="font-weight: bold;">SESSION</span>&nbsp;is a reference to an SNMP session, returned from a previous call to <a href="snmp.html#snmp_open" target="content"><i>snmp.open</i></a>
or <a href="snmp.html#snmp_clone"><span style="font-style: italic;">snmp.clone</span></a>.
The second argument&nbsp;<span style="font-weight: bold;">VARBIND</span>
is varbind table. You can also specificy a varbind list <span style="font-weight: bold;">VARLIST</span>. See <a href="objects.html#varbinds">varbinds</a> for details. The <span style="font-weight: bold;">type</span> field is optional.</p>










<p>The function returns the given varbind or varlist as returned by the SNMP agent. See <a href="#snmp_get">snmp.get</a> for more details. An <span style="font-weight: bold;">error message</span> is additionally returned in case of errors.</p>




















<p>The following example illustrates the use of <span style="font-style: italic; font-weight: bold;">snmp.set </span>:</p>




















<pre>local snmp = require "snmp"<br /><br />hub1, err = snmp.open{<br />&nbsp; peer = "goofy", <br />&nbsp; community = "private", <br />}<br />assert(hub1, err)<br /><br />vbIn = {<br />&nbsp; {oid = "sysContact.0", value = "root"}, &nbsp; <br />  {oid = "sysLocation.0", value="MyHome"}<br />}<br />vbOut, err, index = hub1:set(vbIn)<br />assert(vbOut, err)<br />print(vbOut[1])<br />print(vbOut[2])</pre>




















<p>Note, that there is a metatable attached to the varbinds returned in
the varbind list, which allows to convert the varbind into a readable
string using the <span style="font-style: italic;">tostring&nbsp;</span> Lua function, which is implicitly called by
print. Here is the output of the script above: </p>




















<pre>luasnmp$ lua doc/examples/set.lua<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />SNMPv2-MIB::sysLocation.0 = STRING: MyHome</pre>




















<h4><a name="snmp_asynch_set"></a>reqid, err = snmp.asynch_set(SESSION, VARBIND | VARLIST [,CALLBACK [, MAGIC]])<br />

























reqid, err = SESSION:set(VARBIND | VARLIST [,CALLBACK [, MAGIC]])</h4>




















<p>The function <span style="font-weight: bold; font-style: italic;">snmp.asynch_get&nbsp;</span> performs the same operation as
<span style="font-style: italic;">snmp.get</span>. However, instead of waiting for the request to complete, the
function&nbsp;returns immediately after sending a <i>get-request</i>
message to the agent. When this request completes,&nbsp; a user-defined <span style="font-weight: bold;">CALLBACK</span> function
is&nbsp;invoked.&nbsp;</p>




















<p>Refer to <a href="#snmp_async_get"><span style="font-style: italic; font-weight: bold;">snmp.asynch_get</span></a> for more details on asychronous operation.</p>




















<h4><a name="snmp_getbulk"></a>varbind, err = snmp.getbulk(SESSION, NR, MR, VARS)<br />




















varbind, err = SESSION:getbulk(NR, MR, VARS)</h4>




















<p>The functions <i style="font-weight: bold;">snmp.getbulk&nbsp;</i> performs a&nbsp;SNMPv2 <i>get-bulk </i>operation for the specified session. 
The function is not available for SNMPv1 sessions. Similarly to <i>get-next</i>,
a <i>get-bulk</i> operation retrieves the lexicographical successors of a list of MIB objects. 
The difference is that, by using <i>get-bulk</i> operations, multiple lexicographical successors of
a MIB object can be retrieved in a single protocol operation. 
</p>





















<p>While&nbsp;<i style="font-weight: bold;">snmp.getbulk</i><span style="font-weight: bold; font-style: italic;">&nbsp;</span> performs a&nbsp;<span style="font-style: italic;">synchronous</span> <span style="font-style: italic;">get-bulk</span> operation, which returns only when the operation completes, the function <a href="snmp_asynch_getbulk"><i style="font-weight: bold;">snmp.asynch_getbulk</i></a> operates asynchronously and returns immediately to the caller.<br />




















</p>




















<p>The first argument <span style="font-weight: bold;">SESSION</span> of <i style="font-weight: bold;">snmp.getbulk&nbsp;</i> is a reference to a valid SNMP session.
The fourth argument, <b>VARS</b>, identifies a list of MIB <i>objects</i>, as described for 
<a href="#snmp_getnext" target="content"><i>snmp.getnext</i></a> (a list of <span style="font-weight: bold;">strings</span> or a <i style="font-weight: bold;">varbind list</i>).
The other two arguments, <span style="font-weight: bold;">NR</span> and <span style="font-weight: bold;">MR</span>, specify the number of lexicographical
successors to be retrieved in the following way:
</p>




















<ul>




















  <li><b>NR</b> (Non-Repeaters) specifies the number of objects, starting with the first
object in the <span style="font-weight: bold;">VARS</span> list, for which a <i style="font-weight: bold;">single</i> successor is returned.</li>




















  <li><b>MR</b> (Max-Repetitions) specifies the number of successors to be retrieved
for each of the remaining objects in the <span style="font-weight: bold;">VARS</span> list.</li>




















</ul>






















<p><b style="font-style: italic;">snmp.getbulk&nbsp;</b> returns&nbsp;a <i style="font-weight: bold;">varbind table</i> &nbsp;or a <i style="font-weight: bold;">varbind list</i>, if the operation completes successfully. In case of&nbsp;errors <span style="font-style: italic;">detected locally</span> the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>. In case of errors <span style="font-style: italic;">detected by the agent</span> the returned varbind list&nbsp;may be empty<span style="font-weight: bold;"> </span>or may contain less values as requested, if one or more values
couldn't be retrieved by the agent. Two additional values are then returned: a
string containing the <span style="font-weight: bold;">error
message</span> and an <span style="font-weight: bold;">error
index</span> indicating the first instance that couldn't be
retrieved.</p>





















<p>If a <span style="font-weight: bold;">varbind list</span> is returned, each element of this varbind
list is a fully specified varbind table.
Please notice that the oid<span style="font-style: italic;"> </span>attributes in the varbind
tables returned by <i style="font-weight: bold;">snmp.getbulk&nbsp;</i> always
contain object identifiers in dotted notation.</p>




















<p>The following example illustrates the use of <i>snmp_getbulk</i>. A single invokation of <i>snmp_getbulk</i> retrieves the
 description and type of the first three interfaces of the system. Note in this example the <i><b>nr</b></i> argument set to 0.&nbsp;
</p>




















<pre>local snmp = require "snmp"<br /><br />local ifNum = 3<br /><br />hub1 = assert(snmp.open{peer = "goofy"})<br /><br />ifList, err, index = hub1:getbulk(0, ifNum, {"ifDescr","ifType"})<br />assert(ifList, err)<br /><br />local types = snmp.mib.enums("ifType")<br />i = 1; last=ifNum * 2<br />while i &lt; last do<br />  print(ifList[i].value..": "..types[ifList[i+1].value])<br />  i = i + 2<br />end<br /><br />table.foreach(ifList, print)<br /></pre>




















<p>The above script produces the following output.</p>




















<pre>luasnmp$ lua doc/examples/getbulk.lua<br />lo: softwareLoopback<br />eth0: ethernetCsmacd<br />eth1: ethernetCsmacd<br />1       IF-MIB::ifDescr.1 = STRING: lo<br />2       IF-MIB::ifType.1 = INTEGER: softwareLoopback(24)<br />3       IF-MIB::ifDescr.2 = STRING: eth0<br />4       IF-MIB::ifType.2 = INTEGER: ethernetCsmacd(6)<br />5       IF-MIB::ifDescr.3 = STRING: eth1<br />6       IF-MIB::ifType.3 = INTEGER: ethernetCsmacd(6)</pre>




















<h4><a name="snmp_asynch_getbulk"></a>reqid, err = snmp.asynch_getbulk(SESSION, NR, MR, VARS, [,CALLBACK [,MAGIC]])<br />




















reqid, err = SESSION:asynch_getbulk(VARS, NR, MR [,CALLBACK [, MAGIC]])</h4>




















<p>The function <span style="font-style: italic; font-weight: bold;">snmp.asynch_getbulk&nbsp;</span> performs the same operation as
<span style="font-style: italic;">snmp.getbulk</span>. However, instead of waiting for the request to complete, the
function&nbsp;returns immediately after sending a <i>getnext-request</i>
message to the agent. When this request completes,&nbsp; a user-defined <span style="font-weight: bold;">CALLBACK</span> function
is&nbsp;invoked.&nbsp;</p>




















<p>The&nbsp; <span style="font-weight: bold;">CALLBACK</span> argument is optional. When
present, it specifies a user-defined callback
function to be invoked when the asynchronous operation completes. When
this argument is omitted, the default callback
function, specified when the SNMP session is created, is used.</p>























<p>Each asynchronous operation can be associated with an opaque value <span style="font-weight: bold;">MAGIC</span>,
which is transparently transported to the callback function. Note, that
you can define a request specific magic value even if the request
utilises the session's default callback function.</p>




















<p><b style="font-style: italic;">snmp.asynch_</b><span style="font-style: italic; font-weight: bold;">get</span><span style="font-style: italic;"><span style="font-weight: bold;">bulk&nbsp;</span> </span>returns a <span style="font-weight: bold;">number </span>containing the<i> </i>request id, if the request&nbsp;started successfully. If not, the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>.</p>























<p>When the&nbsp; operation completes, the
user-defined <span style="font-weight: bold;">CALLBACK</span> function is invoked,
receiving up to&nbsp; 6 arguments. The first three arguments are similar to
the values returned from <i>snmp.get</i>: a <span style="font-weight: bold;">varbind
table</span> (or a <span style="font-weight: bold;">varbind list</span>), a <span style="font-weight: bold;">string</span> containint the <span style="font-weight: bold;">error
status</span> or <span style="font-weight: bold;">nil</span>, and an <span style="font-weight: bold;">error index</span>, if an error occurred.
The fourth argument is a number with the <i style="font-weight: bold;">request-id</i><span style="font-weight: bold;"> </span>associated to
the completed
asynchronous request. The fifth&nbsp; argument contains a <span style="font-weight: bold;">reference to the
SNMP session</span>. The last argument is the opaque magic value, which can be of any type.&nbsp;</p>




















<p>If no response is received, LuaSNMP performs the configured number
of retries for the request. If none of these retries succeeds, the
callback function is called with an error status indicating a timeout.</p>



































<h4><a name="snmp_walk"></a>vlist, err, index = snmp.walk(SESSION, NODE)<br />





vlist, err, index = SESSION:walk(NODE)</h4>




















<p>The function <span style="font-weight: bold; font-style: italic;">snmp.walk&nbsp;</span>
uses get-next SNMP primitives to query an agent for a tree of
information. It behaves the same way as the NetSNMP command snmpwalk(1)
does.&nbsp;</p>




















<p>The first parameter <span style="font-weight: bold;">SESSION</span> is the reference to a valid SNMP session. The second parameter <span style="font-weight: bold;">NODE</span> specifies which portion of the object identifier space will be searched. If <span style="font-weight: bold;">NODE</span> is not specified snmp.walk will search in <span style="font-style: italic;">SNMPv2-MIB::mib-2</span>.</p>




















<p>The function returns a list of varbinds, if the operation succeeds.
In case of an error the list of varbinds may be nil or partially
filled. An&nbsp;<span style="font-weight: bold;">error message</span> is additionally returned.</p>




















<p>Here is an example that prints a list of interface types for all interfaces present in the system:</p>




















<pre>require "snmp"<br /><br />hub1 = assert(snmp.open{peer = "goofy"})<br /><br />vlist = assert(hub1:walk("ifType"))<br />table.foreach(vlist, function(k,v) print(v) end)<br /></pre>




















<p>Here is the output:</p>




















<pre>IF-MIB::ifType.1 = INTEGER: softwareLoopback(24)<br />IF-MIB::ifType.2 = INTEGER: ethernetCsmacd(6)<br />IF-MIB::ifType.3 = INTEGER: ethernetCsmacd(6)<br />IF-MIB::ifType.4 = INTEGER: ethernetCsmacd(6)<br />IF-MIB::ifType.5 = INTEGER: tunnel(131)<br /></pre>




















<p>Normally <span style="font-style: italic; font-weight: bold;">snmp.walk&nbsp;</span>
uses get-next requests&nbsp;starting with the OID
you&nbsp;specified&nbsp; and returns&nbsp; all&nbsp; results&nbsp;
in&nbsp; the&nbsp; MIB subtree rooted at that OID. If you want&nbsp;to
include the OID specified in the NODE parameter on the commandline,
configure the session with the parameter <span style="font-style: italic; font-weight: bold;">includeroot = true.</span></p>




















<p>If you do so, the example above produces the following output.</p>




















<pre>IF-MIB::ifType = No Such Instance currently exists at this OID<br />IF-MIB::ifType.1 = INTEGER: softwareLoopback(24)<br />IF-MIB::ifType.2 = INTEGER: ethernetCsmacd(6)<br />IF-MIB::ifType.3 = INTEGER: ethernetCsmacd(6)<br />IF-MIB::ifType.4 = INTEGER: ethernetCsmacd(6)<br />IF-MIB::ifType.5 = INTEGER: tunnel(131)<br /></pre>




















<p></p>




















<h4><a name="snmp_inform"></a>vlist, err, errindex = snmp.inform(SESSION, TRAPOID, VARLIST)<br />




















vlist, err, errindex = SESSION:inform(TRAPOID, VARLIST)</h4>




















<p>The function snmp.inform sends a solicited trap to another SNMP manager.&nbsp;</p>




















<p>While <i style="font-weight: bold;">snmp.inform&nbsp;</i>
performs a&nbsp;<span style="font-style: italic;">synchronous</span> set operation which&nbsp;returns only when
the operation completes,&nbsp; the function <a href="snmp.html#snmp_async_inform"><i style="font-weight: bold;">snmp.asynch_inform</i></a>
(see below) operates asynchronous and returns immediately to the caller.&nbsp;</p>




















<p>The first parameter <span style="font-weight: bold;">SESSION</span>
defines a valid SNMP session, which must have been configured to send
on a port on which a trap sink listens for traps. This will be
typically port 162. The second parameter <span style="font-weight: bold;">TRAPOID</span> identifies the trap to be sent. The third parameter VARLIST is a <span style="font-weight: bold;">varbind list</span> containing additional information for the recipient.</p>




















<p>Example without trap callback:</p>




















<pre>require "snmp"<br /><br />hub1 = assert(snmp.open{peer = "localhost"})<br />hub1trap = hub1:clone{port = 162}<br /><br />local vlist = assert(hub1:get{"sysContact.0", "sysUpTime.0"})<br />local result, err = hub1trap:inform("sysName.0", vlist)<br />table.foreach(result, print)<br /></pre>




















<p>This will produce the following output:</p>




















<pre>luasnmp$ lua doc/examples/inform.lua<br />DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (0) 0:00:00.00<br />SNMPv2-MIB::snmpTrapOID.0 = OID: SNMPv2-MIB::sysName.0<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (5199693) 14:26:36.93<br /></pre>




















<h4><a name="snmp_asynch_inform"></a>reqid, err = snmp.asynch_inform(SESSION, TRAPOID, VARLIST [,CALLBACK [, MAGIC]])<br />




















reqid, err = SESSION:asynch_inform(TRAPOID, VARLIST [,CALLBACK [, MAGIC]])</h4>




















<p>The function <span style="font-weight: bold; font-style: italic;">snmp.asynch_inform&nbsp; </span>performs the same operation as
<span style="font-style: italic;"><a style="font-weight: bold;" href="#snmp_inform">snmp.inform</a>.</span> However, instead of waiting for the request to complete, the
function&nbsp;returns immediately after sending a <i>getnext-request</i>
message to the agent. When this request completes,&nbsp; a user-defined <span style="font-weight: bold;">CALLBACK</span> function
is&nbsp;invoked.&nbsp;</p>




















<p>The&nbsp; <span style="font-weight: bold;">CALLBACK</span> argument is optional. When
present, it specifies a user-defined callback
function to be invoked when the asynchronous operation completes. When
this argument is omitted, the default callback
function, specified when the SNMP session is created, is used.</p>























<p>Each asynchronous operation can be associated with an opaque value <span style="font-weight: bold;">MAGIC</span>,
which is transparently transported to the callback function. Note, that
you can define a request specific magic value even if the request
utilises the session's default callback function.</p>




















<p><b style="font-style: italic;">snmp.asynch_</b><span style="font-style: italic; font-weight: bold;">inform </span><span style="font-style: italic;"><span style="font-weight: bold;"></span> </span>returns a <span style="font-weight: bold;">number </span>containing the<i> </i>request id, if the request&nbsp;started successfully. If not, the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span>.</p>























<p>When the&nbsp; operation completes, the
user-defined <span style="font-weight: bold;">CALLBACK</span> function is invoked,
receiving up to&nbsp; 6 arguments. The first three arguments are similar to
the values returned from <i>snmp.get</i>: a <span style="font-weight: bold;">varbind
table</span> (or a <span style="font-weight: bold;">varbind list</span>), a <span style="font-weight: bold;">string</span> containint the <span style="font-weight: bold;">error
status</span> or <span style="font-weight: bold;">nil</span>, and an <span style="font-weight: bold;">error index</span>, if an error occurred.
The fourth argument is a number with the <i style="font-weight: bold;">request-id</i><span style="font-weight: bold;"> </span>associated to
the completed
asynchronous request. The fifth&nbsp; argument contains a <span style="font-weight: bold;">reference to the
SNMP session</span>. The last argument is the opaque magic value, which can be of any type.&nbsp;</p>




















<p></p>




















<h4><a name="snmp_wait"></a>err = snmp.wait(SESSION)<br />




















err = SESSION:wait()</h4>




















<p>The function snmp.wait waits until all asynchronous events pending for the given <span style="font-weight: bold;">SESSION</span>
have completed. The function receives a reference to a valid SESSION as
parameter. Note, that although&nbsp;snmp.wait&nbsp;waits until ALL
pending events of the GIVEN session have completed, responses of other
session are processed as well.</p>




















<p>The example script and it's output show the behaviour of snmp.wait.
During the wait phase of hub1 the first request of hub2 is also
processed. Since there is only one request from hub1, <span style="font-style: italic;">hub1:wait&nbsp;</span> completes after this and the second request of hub2 is process during <span style="font-style: italic;">hub2:wait&nbsp;</span></p>




















<pre>local snmp = require "snmp"<br /><br />function func_cb(vb, status, index, reqid, session, magic)<br />  if magic == "goofy" then<br />    print("Callback: from goofy")<br />  else<br />    print("Callback: from localhost")<br />  end<br />  print(vb)<br />end<br /><br />hub1 = assert(snmp.open{peer = "goofy"})<br />hub2 = assert(hub1:clone{peer = "localhost"})<br /><br />local reqid1 = hub1:asynch_get("sysContact.0", func_cb, "goofy")<br />local reqid2 = hub2:asynch_get("sysContact.0", func_cb, "localhost")<br />local reqid2 = hub2:asynch_get("sysName.0", func_cb, "localhost")<br /><br />print("Waiting for hub1 ...")<br />hub1:wait()<br />print("Waiting for hub2 ...")<br />hub2:wait()<br /></pre>




















<p>Output:<br />




















</p>




















<pre>luasnmp$ lua doc/examples/wait.lua<br />Waiting for hub1 ...<br />Callback: from localhost<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />Callback: from goofy<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />Waiting for hub2 ...<br />Callback: from localhost<br />SNMPv2-MIB::sysName.0 = STRING: goofy</pre>




















<h4><a name="snmp_loop"></a>snmp.idle()<br />




















snmp.loop()</h4>




















<p>The function snmp.loop or snmp.idle provides an event loop. A
LuaSNMP scripts remains in snmp.loop as long as there are uncompleted
asynchronous operations and as long as there is a session with a trap
callback function waiting for trap notifications. The function returns,
when all asynchronous requests are completed and all trap capturing
sessions have been closed.</p>




















<h4><a name="snmp_event"></a>snmp.event()</h4>




















<p>The function <span style="font-weight: bold; font-style: italic;">snmp.event</span> checks for incoming responses from agents.
It does NOT wait for responses. The function is useful in case you want
to wait for different events (e.g. from a GUI) in a single loop.</p>




















<pre>while true do<br />  - Look for SNMP responses and invoke callback functions accordingly.<br />  snmp.event()<br />  - Wait for events from other packages<br />  ...<br />end<br /></pre>













<h2><a name="user_mgmt"></a>SNMPv3 User Management</h2>










<h4><a name="snmp_createuser"></a>var, err = snmp.createuser(SESSION, USER [,CLONEFROM])</h4>










<p>The function <span style="font-weight: bold; font-style: italic;">snmp.createuser</span> creates a new SNMPv3 <span style="font-weight: bold;">USER</span> &nbsp;on the remote machine, which is reachable via the given <span style="font-weight: bold;">SESSION</span>. The newly created user will not be active until an existing <span style="font-weight: bold;">CLONEFROM</span> user has been assigned to USER. Cloning assigns authentication parameters from the existing user <span style="font-weight: bold;">CLONEFROM</span> to <span style="font-weight: bold;">USER</span>. This can happen in 2 ways:</p>










<ul>










  <li>Define a second user CLONEFROM when creating USER via <a href="#snmp_createuser">snmp.createuser</a></li>










  <li>Define the CLONEFROM in a second step using the function <a href="#snmp_clonefrom">snmp.clonefromuser</a></li>










</ul>










<p>The function returns a varbind (CLONEFROM omitted) containing the object <span style="font-weight: bold; font-style: italic;">usmUserStatus</span>&nbsp;or a varlist containing the objects <span style="font-weight: bold; font-style: italic;">userCloneFrom</span> and <span style="font-weight: bold; font-style: italic;">userSecurityName</span>. If an error occurs the varbind or varlist may be incomplete or <span style="font-weight: bold;">nil</span> and &nbsp;the function also returns &nbsp;an <span style="font-weight: bold;">error message</span>.</p>









<p>Example:</p>









<pre>local snmp = require "snmp"<br />local mib = snmp.mib<br /><br />--<br />-- We will use this frequently<br />--<br />local check = snmp.check<br /><br />--<br />-- Lets define a convenient print function<br />--<br />function printf(fmt, ...)<br />  print(string.format(fmt, unpack(arg)))<br />end<br /><br />--<br />-- User to create<br />--<br />local user = "popey"<br /><br />--<br />-- User to clone from<br />--<br />local clonefromuser = "ronja"<br /><br />--<br />-- Open a working session<br />--<br />local sess, err = snmp.open{<br />  peer = "goofy",<br />  version = snmp.SNMPv3,<br />  user = "leuwer",<br />  password = "leuwer2006"<br />}<br />check(sess, err)<br /><br />--<br />-- Create the user 'popey'<br />--<br />local vl, err = check(sess:createuser(user, clonefromuser))<br />for _,v in ipairs(vl) do print(v) end<br /><br />--<br />-- Read and print popey's usmUserStatus<br />--<br />print(check(sess:get(mib.oid("usmUserStatus") .. snmp.instance(sess.contextEngineID, user))))<br /><br />--<br />-- Delete the user again<br />--<br />local vb, err = check(sess:deleteuser(user))<br /><br />--<br />-- Read and print popey's usmUserStatus<br />--<br />print(check(sess:get(mib.oid("usmUserStatus") .. mib.instance(sess.contextEngineID, user))))<br /><br />--<br />-- Close the working session<br />--<br />check(not sess:close())</pre>










<h4><a name="snmp_clonefrom"></a>varlist, err = snmp.clonefromuser(SESSION, USER, CLONEFROM)</h4>










<p>The function <span style="font-weight: bold; font-style: italic;">snmp.clonefromuser</span> clones authentication parameters from an exisiting and active user <span style="font-weight: bold;">CLONEFROM</span> to a newly created&nbsp;<span style="font-weight: bold;">USER</span>. Note, that both users must exist before <span style="font-weight: bold; font-style: italic;">snmp.clonefromuser</span> is called.</p>










<p>The function returns a varlist containing the objects&nbsp; <span style="font-weight: bold; font-style: italic;">userCloneFrom</span> and <span style="font-weight: bold; font-style: italic;">userSecurityName</span>. If an error occurs the varlist may not be complete or even <span style="font-weight: bold;">nil</span> and the function also returns an <span style="font-weight: bold;">error message</span>.</p>










<h4>varbind, err = snmp.deleteuser(SESSION, USER)</h4>










<p>The function <span style="font-weight: bold;">snmp.deleteuser</span> deletes the given <span style="font-weight: bold;">USER</span> on the remote machine that is reachable via the given <span style="font-weight: bold;">SESSION</span>. The user to be deleted may be in any state.&nbsp;</p>










<p>The function returns a the object <span style="font-weight: bold; font-style: italic;">usmUserStatus</span> as varbind,&nbsp; with a <span style="font-style: italic; font-weight: bold;">value = snmp.rowStatus.destroy</span>.&nbsp;If an error occurs varbind may be nil or incomplete. An <span style="font-weight: bold;">error message</span> is additionally returned.&nbsp;</p>













<h4><a name="snmp_newpassword"></a>varlist, err = snmp.newpassword(SESSION, OLDPW, NEWPW, FLAG, USER)</h4>













<p>The function <span style="font-weight: bold; font-style: italic;">snmp.newpassword</span> changes an SNMPv3&nbsp;user's password in a remote machine, which is reachable via the given <span style="font-weight: bold;">SESSION</span>. The password of the given <span style="font-weight: bold;">USER</span> is changed from <span style="font-weight: bold;">OLDPW</span> to <span style="font-weight: bold;">NEWPW</span>. The optional parameter flag takes one of the following values&nbsp;</p>













<ul>













  <li>"a" Change only the authentication password</li>













  <li>"ap" Change both, the authentication password and the privacy (encryption) password</li>













  <li>"p" Change only the privacy password</li>













</ul>













<p>If <span style="font-weight: bold;">USER</span> is omitted, the password of the given <span style="font-weight: bold;">SESSION</span> user is changed.</p>













<p>Upon success the function returns a varlist containing the
corresponding key change objects. In case of any error an
error message indicating an error index &nbsp;is returned.&nbsp;</p>












<p>Note, that previous session based on OLDPW become unusable after
changing the password. Any request using such a session results in an
authentication error. To continue work with the changed password a new
session has to be created.&nbsp;</p>












<p>Example:</p>












<pre>local snmp = require "snmp"<br /><br />-- User who's password to change<br />local user = "ronja"<br /><br />-- Old an new passwords<br />local oldpw = "ronja2006"<br />local newpw = "mydog2006"<br /><br />--<br />-- Create a work session which we use to change the password<br />--<br />local sess, err = snmp.open{<br />  peer = "goofy",<br />  version = snmp.SNMPv3,<br />  user = "leuwer",<br />  password = "leuwer2006"<br />}<br /><br />--<br />-- Create an "old" session using OLDPW<br />--<br />local sessold = assert(snmp.open{<br />  peer = "localhost",<br />  version = snmp.SNMPv3,<br />  user = user,<br />  password = oldpw})<br /><br />--<br />-- Change password implicit using the user's session.<br />--<br />local vl = assert(sessold:newpassword(oldpw, newpw, "a"))<br />for _,v in ipairs(vl) do print(v) end<br /><br />--<br />-- Create a "new" session using NEWPW for the user<br />--<br />local sessnew = assert(sessold:clone{password = newpw})<br /><br />--<br />-- Use the "new" session<br />--<br />print(assert(sessnew:get("sysContact.0")))<br /><br />--<br />-- Change password back from NEWPW to OLDPW explicitly<br />-- using the worker session<br />--<br />vl = assert(sess:newpassword(newpw, oldpw, "a", user))<br />for _,v in ipairs(vl) do print(v) end<br /><br />--<br />-- Reopen the old session. This will reuse OLDPW.<br />--<br />sessold2 = assert(sessold:clone())<br /><br />--<br />-- Use the reopened session<br />--<br />vb = assert(sessold2:get("sysContact.0"))<br />print(vb)<br /><br />--<br />-- Close all sessions created<br />--<br />assert(not sessold:close())<br />assert(not sessnew:close())<br />assert(not sessold2:close())<br />assert(not sess:close())<br /></pre>






<br />






<h4><a name="snmp_createkey"></a>key, keylen = snmp.createkey(SESSION, PASSWORD [,HASHTYPE])</h4>












<p>The function <span style="font-weight: bold; font-style: italic;">snmp.createkey </span>creates an authentication key from a given PASSWORD according to RFC 2274. The generator uses the algorithm defined in <span style="font-weight: bold;">HASHTYPE</span> for key generation. I this parameter is omitted, the function determines the hash type from the given <span style="font-weight: bold;">SESSION</span>.</p>












<p>The function returns the key as Lua <span style="font-weight: bold;">string</span> (note, that this string may contain embedded zeros) and the length of the key as <span style="font-weight: bold;">number</span>. In case of errors the function return a <span style="font-weight: bold;">nil</span> key and an <span style="font-weight: bold;">error message</span> in keylen.</p>












<p>The following hash types are supported:</p>












<ul>












  <li>MD5: use <span style="font-weight: bold;">snmp.usmProtocol.HMACMD5Auth&nbsp;</span>for HASHTYPE</li>












</ul>












<ul>












  <li>SHA1: use <span style="font-weight: bold;">snmp.usmProtocol.HMACSHA1Auth </span>for HASHTYPE</li>












</ul>












<p>This function is internally used in higher level USM management routines like <a href="#snmp_newpassword">snmp.newpassword</a>.</p>












<p>Note, that localized keys instead of passwords are currently not supported.</p>












<h4><a name="snmp_createlocalkey"></a>key, keylen = snmp.createlocalkey(SESSION, KEY [,HASHTYPE] [,ENGINEID])</h4>












<p>The function <span style="font-style: italic; font-weight: bold;">snmp.createlocalkey</span> creates a localised &nbsp;form of <span style="font-weight: bold;">KEY</span> at <span style="font-weight: bold;">ENGINEID</span> according to RFC2274. <span style="font-weight: bold;">KEY</span> is a Lua <span style="font-weight: bold;">string</span> containing an authentication key produced by <a href="#snmp_createkey">snmp.createkey</a>. The generator uses the algorithm defined in <span style="font-weight: bold;">HASHTYPE</span> for key generation (see&nbsp;<a href="snmp.html#snmp_createkey">snmp.createkey</a>) . I this parameter is omitted, the function determines the hash type from the given <span style="font-weight: bold;">SESSION</span>. The context engine ID&nbsp;is either explicitly defined as <span style="font-weight: bold;">ENGINEID</span> or taken from the given <span style="font-weight: bold;">SESSION</span>.&nbsp;</p>












<p>The function returns the key as Lua <span style="font-weight: bold;">string</span> (note, that this string may contain embedded zeros) and the length of the key as <span style="font-weight: bold;">number</span>.&nbsp;In case of errors the function return a <span style="font-weight: bold;">nil</span> key and an <span style="font-weight: bold;">error message</span> in keylen.</p>












<p>This function is internally used in higher level USM management routines like <a href="snmp.html#snmp_newpassword">snmp.newpassword</a>.</p>












<h4><a name="snmp_keychange"></a>kcstring, kcstringlen = snmp.keychange(SESSION, OLDKEY, OLDKEYLEN, NEWKEY, NEWKEYLEN, [,HASHTYPE])</h4>












<p>The function <span style="font-weight: bold; font-style: italic;">snmp.keychange</span> uses <span style="font-weight: bold;">OLDKEY</span> and acquired random bytes to encode <span style="font-weight: bold;">NEWKEY</span> into <span style="font-weight: bold;">kcstring</span> and kcstringlen according to the rules of the KeyChange TC described in RFC 2274.</p>












<p>This function is internally used to encode a password change from old to new in&nbsp;<a href="snmp.html#snmp_newpassword">snmp.newpassword</a>.</p>






<h1><a name="vacm"></a>View based Access Control </h1>






<h4><a name="vacm_sec2group"></a>varlist, err = snmp.createsectogroup(SESSION, SECMODEL, SECNAME, GROUPNAME)</h4>





<p>The function <span style="font-style: italic; font-weight: bold;">snmp.createsectogroup</span> creates an entry in the security name to group table of a remote element reachable via a valid <span style="font-weight: bold;">SESSION</span>. The function receives the security model <span style="font-weight: bold;">SECMODEL</span> (<span style="font-weight: bold;">"SNMPv1", "SNMPv2" or "USM"</span>)&nbsp; and a security name <span style="font-weight: bold;">SECNAME</span> as <span style="font-weight: bold;">string</span> parameter. These two values are then used as index to create an entry for the group with name <span style="font-weight: bold;">GROUPNAME</span>, given as <span style="font-weight: bold;">string</span>.</p>





<p>The group is later referenced by <a style="font-weight: bold; font-style: italic;" href="#vacm_createaccess">snmp.createaccess</a>.</p>





<p>If the operation succeeds, <span style="font-weight: bold; font-style: italic;">snmp.createsectogroup</span> returns a <span style="font-weight: bold;">varlist</span> of two <a href="objects.html#varbinds">varbinds</a> containing the agent's response, which is <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::</span><span style="font-weight: bold;">vacmSecurityToGroupStatus</span> with value <span style="font-weight: bold; font-style: italic;">rowStatus.createAndGo</span> and <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::</span><span style="font-weight: bold;">vacmGroupName</span> carrying the group's name. In case of an error <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">error message</span> is returned indicating the type and location (varbind index in varlist) of the error.</p>





<p>See <a href="#vacm_createaccess"><span style="font-weight: bold; font-style: italic;">snmp.createaccess</span></a> for a complete example on how to use the VACM functions.</p>






<h4><a name="vacm_delete_sec2group"></a>varbind, err = snmp.deletesectogroup(SESSION, SECMODEL, SECNAME)</h4>





<p>Deletes an entry in the name to group security table&nbsp;<span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::</span><span style="font-weight: bold;">vacmSecuritytoGroupStatus</span> of a remote element addressed by SESSION.&nbsp;</p>





<p>If the entry could be successfully deleted, the function returns a varbind containing <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::</span><span style="font-weight: bold;">vacmSecuritytoGroupStatus</span> set to <span style="font-weight: bold;">rowStatus.destroy</span>. In case of an error the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">errormessage</span>.</p>






<h4><a name="vacm_createview"></a>varlist, err = snmp.createview(SESSION, VIEWNAME, SUBTREE, MASK [,FLAG])</h4>





<p>The function <span style="font-weight: bold;">snmp.createview</span> creates a new entry in the <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::vacmViewTreeFamilyTable. </span>The parameter <span style="font-weight: bold;">VIEWNAME</span> is the name of the view. <span style="font-weight: bold;">SUBTREE</span> designates the root OID of the subtree that is added to the view. <span style="font-weight: bold;">MASK</span> is a&nbsp; bitmask that indicates which subidentifiers of the given tree are significant. The optional parameter <span style="font-weight: bold;">FLAG</span> is string that defines whether the SUBTREE is included (FLAG = <span style="font-weight: bold;">"inc(lude)"</span>) or excluded (FLAG=<span style="font-weight: bold;">"exc(lude)"</span>) from the view. The default is <span style="font-weight: bold;">"include"</span>.</p>





<p>Upon success the function returns a varlist containing the new entry in <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::vacmViewTreeFamilyTable.&nbsp;<br />





</span>The following objects of the entry are returned:
vacmViewTreeFamilyStatus (createAndGo), vacmViewTreeFamilyMask (as
given by MASK) and vacmViewTreeFamilyType ("include" or "exclude"). If
an error occurs the function return <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">errormessage</span> indicating the first varbind in the varlist that failed.</p>





<h4><a name="vacm_delete_view"></a>varbind, err = snmp.deleteview(SESSION, VIEWNAME, SUBTREE)</h4>





<p>Deletes an entry in the view table <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::vacmViewTreeFamilyTable.&nbsp;</span>If the entry could be successfully deleted, the function returns a varbind containing <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::</span><span style="font-weight: bold;">vacmViewTreeFamilyStatus</span> set to <span style="font-weight: bold;">rowStatus.destroy</span>. In case of an error the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">errormessage</span>.</p>






<h4><a name="vacm_createaccess"></a>varlist, err =
snmp.createaccess(SESSION, GROUPNAME, SECMODEL, SECLEVEL, CONTEXTMATCH,
READVIEW, WRITEVIEW, NOTIFYVIEW [,CONTEXTPREFIX])&nbsp;</h4>





<p>The function <span style="font-weight: bold; font-style: italic;">snmp.createaccess</span> creates an entry int the SNMPv3 access table <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::vacmAccessTable </span>of<span style="font-weight: bold;"> </span>the remote element reachable via the given SESSION.<span style="font-weight: bold;"> </span>The access writes are those described by&nbsp; the given <span style="font-weight: bold;">GROUPNAME</span>, <span style="font-weight: bold;">SECMODEL</span> and <span style="font-weight: bold;">SECLEVEL</span>. The parameter <span style="font-weight: bold;">CONTEXTMATCH</span>
defines how the optionally given CONTEXTPREFIX is interpreted: either
"exact" or "prefix". The CONTEXTPREFIX is either an empty string, a
single context or a collection of contexts.&nbsp;</p>





<p>The MIB scope is defined differently for read, write and notification access using the view names <span style="font-weight: bold;">READVIEW</span>, <span style="font-weight: bold;">WRITEVIEW</span> and <span style="font-weight: bold;">NOTIFYVIEW</span>. </p>





<p>Upon success the function returns a varlist containing the new entry in <span style="font-weight: bold;">SNMP-VIEW-BASE-ACM-MIB::vacmAccessTable. </span>If an error occurs the function returns nil plus an <span style="font-weight: bold;">errormesage</span> indicating the first object with a failure in the varlist.</p>





<p>Example:</p>





<pre>local snmp = require "snmp"<br />local mib = snmp.mib<br /><br />-- We will use this frequently - so let's have a local ref<br />local check = snmp.check<br /><br />--<br />-- Open a working session<br />--<br />local sess, err = check(snmp.open{<br />  peer = "localhost",<br />  version = snmp.SNMPv3,<br />  user = "leuwer",<br />  password = "leuwer2006",<br />			})<br />--<br />-- Create a user to give access to.<br />--<br />local vl = check(sess:createuser("olivia", "ronja"))<br /><br />--<br />-- The new user typically needs a new password. <br />--<br />vl = check(sess:newpassword("ronja2006", "gonzo2006", "a", "olivia"))<br /><br />--<br />-- Create security name to group mapping.<br />--<br />vl, err = sess:createsectogroup("usm", "olivia", "rwgroup")<br />if err then<br />  -- <br />  -- An error occurred: cleanup and delete the above new user here.<br />  --<br />  vl = check(sess:deleteuser("olivia"))<br />  sess:close()<br />  os.exit(1)<br />end<br /><br />--<br />-- Create a new view 'interfaces'<br />--<br />vl = check(sess:createview("interfaces", mib.oid("ifTable"), "80", "include"))<br /><br />--<br />-- Create a new access entry for the new group.<br />--<br />vl = check(sess:createaccess("rwgroup", "usm", "authNoPriv", "exact", <br />			     "interfaces", "interfaces", "_none_"))<br /><br />--<br />-- Let's have a look at all this stuff<br />--<br />table.foreach(sess:walk("vacmAccessTable"), print)<br /><br />-- Finished: now we could test gos and nogos in the access.<br />-- Cleanup all newly created stuff.<br />--<br />vl = check(sess:deleteaccess("rwgroup", "usm", "authNoPriv"))<br />vl = check(sess:deleteview("interfaces", mib.oid("ifTable")))<br />vl = check(sess:deletesectogroup("usm", "olivia"))<br />vl = check(sess:deleteuser("olivia"))<br />sess:close()<br /></pre>





<h4><a name="vacm_delete_access"></a>varbind, err = snmp.deleteaccess(SESSION, GROUPNAME, SECMODEL, SECLEVEL [,CONTEXTPREFIX]) </h4>






<p>Deletes an entry in the <span style="font-weight: bold;">SNMP-VIEW-BASED-ACM-MIB::vacmAccessTable. </span>If
the entry could be successfully deleted the function returns a varbind
containing the table entry's row status set to destroy. In case of an
error the function returns <span style="font-weight: bold;">nil</span> plus an <span style="font-weight: bold;">errormessage</span>.</p>












<h2><a name="data_conversion"></a>Data Conversion</h2>














<h4><a name="snmp_newvar"></a>varbind = snmp.newvar(NAME, VALUE [,TYPE] [,SESSION])</h4>
















<p>The function <span style="font-weight: bold; font-style: italic;">snmp.newvar</span> creates a new <a href="objects.html#varbinds">varbind</a> instance. <span style="font-weight: bold;">NAME</span>
designates the SNMP node via a symbolic name or via an objects
identifier in dotted notation. The varbind receives <span style="font-weight: bold;">VALUE</span> as its value. A <span style="font-weight: bold;">TYPE</span> can be optionally defined. If omitted, LuaSNMP determines the object type using the NAME and the global MIB tree.</p>












<p> The optional parameter <span style="font-weight: bold;">SESSION</span> is stored in a hidden field and
is currently not used.&nbsp;</p>
















<p>LuaSNMP sets appropriate metamethods for the varbind table for printing, concatenation and arithmetic (see <a href="objects.html#varbinds">varbinds</a>).</p>
















<p>A typical usage of this function is the preparation of variable bindings for set-request operations.</p>




















<h4><a name="snmp_sprintvar"></a>result = snmp.sprintvar(VAR)<br />



















result = snmp.sprintvar2(VAR)<br />



















result = SESSION.sprintvar(VAR)</h4>



















<p>Converts the given varbind <span style="font-weight: bold;">VAR</span> into a printable <span style="font-weight: bold;">string</span>. The function can be called either in <span style="font-weight: bold;">snmp</span> namespace or as a <span style="font-weight: bold;">method of a valid SNMP session</span>. The second method allows to override the function by specifiying the <span style="font-weight: bold;">sprintvar</span> configuration parameter during session creation.</p>

















<p><span style="font-weight: bold;">snmp.sprintvar2</span> is just another variant to convert a varbind to a printable string.</p>



















<p>Note, that you can also apply the standard Lua SNMP <span style="font-weight: bold; font-style: italic;">tostring</span> function to varbinds returned by LuaSNMP. See&nbsp;<a href="objects.html#varbinds"><span style="font-weight: bold;">Varbinds</span></a> for details.</p>



















<p>The following example illustrates the usage of the various conversion functions:</p>



















<pre>local snmp = require "snmp"<br /><br />hub1 = assert(snmp.open{peer = "goofy"})<br /><br />vb = assert(hub1:get("sysContact.0"))<br />print("OUTPUT of 'sprintvar':")<br />print(vb)<br />print(snmp.sprintvar(vb))<br />print(hub1.sprintvar(vb))<br />print(snmp.sprintvar2(vb))<br />print()<br />print("OUTPUT of 'sprintval':")<br />print(snmp.sprintval(vb))<br />print(snmp.sprintval2(vb))<br />print()<br />print("OUTPUT of 'sprinttype':")<br />print(snmp.sprinttype(vb))<br />print(snmp.mib.typename(vb))<br /><br /></pre>



















<p>The above script generates the following output. Don't be confused
about the relation Integer32 and STRING. This is caused by official
SNMP typecodes and their translation into typenames.</p>



















<pre>luasnmp$ lua doc/examples/sprint.lua<br />OUTPUT of 'sprintvar':<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />SNMPv2-MIB::sysContact.0 = STRING: root<br />sysContact.0 (Integer32) = STRING: root<br /><br />OUTPUT of 'sprintval':<br />STRING: root<br />root<br /><br />OUTPUT of 'sprinttype':<br />Integer32<br />Integer32</pre>




















<h4><a name="snmp_sprintval"></a>result = snmp.sprintval(VAR)<br />



















result = snmp.sprintval2(VAR)<br />



















result = SESSION.sprintval(VAR)</h4>



















<p>Converts the value of a given <span style="font-weight: bold;">VAR</span> into a printable string. See <a style="font-weight: bold; font-style: italic;" href="snmp_sprintvar">snmp.sprintvar</a> for details and an example.</p>



















<h4><a name="snmp_sprinttype"></a>result = snmp.sprinttype(VAR)<br />



















</h4>



















<p>Converts the type&nbsp; of a given <span style="font-weight: bold;">VAR</span> into a printable string. See <a style="font-weight: bold; font-style: italic;" href="snmp_sprintvar">snmp.sprintvar</a> for details and an example.</p>













<h4><a name="snmp_sprintkey"></a>str = snmp.sprintkey(KEY [,LEN])<br />







str = snmp.key2octet(KEY [, LEN])<br />













str = snmp.octetstring(KEY [, LEN])</h4>













<p>Converts the string <span style="font-weight: bold;">KEY</span> containing any character code (even 0x00) into a OCTET STRING&nbsp; representation of the form&nbsp;<span style="font-style: italic; font-weight: bold;">01:02:0a:0b</span>. This representation can be used to set a string value with embedded zeros in a varbind.&nbsp;The optional parameter <span style="font-weight: bold;">LEN</span> defines how many
characters are to evaluated. If omitted the whole string is converted.</p>













<p>Examples:</p>













<pre>luasnmp$ lua -l snmp -i<br />&gt; key=string.char(1,2,3,4,5,10,11,12)<br />&gt; =string.len(key)<br />8<br />&gt; =snmp.octetstring(key)<br />01:02:03:04:05:0a:0b:0c<br />&gt; =snmp.key2oid(key)<br />1.2.3.4.5.10.11.12<br />&gt; =snmp.key2hex(key)<br />0x01020304050A0B0C<br />&gt; return snmp.key2octet(key,6)<br />01:02:03:04:05:0a<br />&gt; return snmp.key2octet(key,9)<br />01:02:03:04:05:0a:0b:0c<br /></pre>













<h4><a name="snmp_sprintkeyd"></a>str = snmp.sprintkeyd(KEY, LEN)<br />













str = snmp.key2oid(KEY, LEN)</h4>













<p>Converts the string <span style="font-weight: bold;">KEY</span> containing any character code (even 0x00) into an OID representation <span style="font-style: italic; font-weight: bold;">1.2.10.11</span>. The optional parameter <span style="font-weight: bold;">LEN</span> defines how many characters are to evaluated. If omitted the whole string is converted.</p>








<p>See <a href="#snmp_sprintkey">snmp.key2octet</a> for examples.</p>













<h4><a name="snmp_sprintkeyx"></a>str = snmp.sprintkeyx(KEY, LEN)<br />













str = snmp.key2hex(KEY, LEN</h4>













<p>Converts the string <span style="font-weight: bold;">KEY</span> containing any character code (even 0x00) into an hexadecimal readable&nbsp;representation<span style="font-style: italic; font-weight: bold;"> 0x01020A0B</span>. The optional parameter <span style="font-weight: bold;">LEN</span> defines how many characters are to evaluated. If omitted the whole string is converted.</p>













<p>See <a href="snmp.html#snmp_sprintkey">snmp.key2octet</a> for examples.</p>













<h4><a name="snmp_uptimev2s"></a>result = snmp.uptimeV2S(TICKS)<br />



















result = snmp.uptimeS2V(TIME)</h4>



















<p>These functions convert SNMP timetick values into a formatted strings&nbsp;and vice versa.&nbsp;</p>



















<p><span style="font-weight: bold; font-style: italic;">snmp.uptimeV2S</span> receives a number containing <span style="font-weight: bold;">TICKS</span>&nbsp; and returns a formatted <span style="font-weight: bold;">string</span> containing the time&nbsp; human readable format.</p>



















<p>snmp.uptimeS2V receives a formatted string <span style="font-weight: bold;">TIME</span> and returns a table with the following fields:<br />



















days, hours, minutes, seconds, deciseonds and ticks.</p>



















<p>Here is an example:</p>



















<pre>local snmp = require "snmp"<br /><br />hub1 = assert(snmp.open{peer = "goofy"})<br /><br />vb = assert(hub1:get("sysUpTime.0"))<br />print(vb)<br /><br />time = snmp.uptimeV2S(vb.value)<br />ticks = snmp.uptimeS2V(time)<br /><br />print(time)<br />table.foreach(ticks, print)<br /></pre>



















<p>Output:</p>



















<pre>luasnmp$ lua doc/examples/uptime.lua<br />DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (383697) 1:03:56.97<br />0:1:3:56.97<br />minutes 3<br />deciseconds     97<br />ticks   383697<br />hours   1<br />days    0<br />seconds 56<br /><br /></pre>













<h2><a name="exceptions"></a>Finalized Exceptions</h2>


<p>LuaSNMP provides the Finalized Exceptions concept designed by Diego Nehab for luasocket. See <a href="http://lua-users.org/wiki/FinalizedExceptions">here</a> for details. </p>


<h4><a name="snmp_protect"></a>result = snmp.protect(FUNCTION)</h4>


<p class="description">Converts a function that throws exceptions&nbsp;
into a safe function. This
function only catches exceptions thrown by a try function -&nbsp;either
the predefined snmp.try or a&nbsp; try function, that was newly created
via <a href="#snmp_newtry"><span style="font-weight: bold; font-style: italic;">snmp.newtry</span></a>.&nbsp;It does not catch normal 
Lua errors.
</p>






<p class="return">
<span style="font-weight: bold;">FUNCTION</span> is a function that calls try (or assert or error) 
to throw exceptions. Function <span style="font-weight: bold; font-style: italic;">snmp.protect</span> returns&nbsp; an equivalent function that instead of throwing exceptions,
returns <tt><b>nil</b></tt> followed by an <span style="font-weight: bold;">error message.</span> 
</p>




<p class="note">
Note: Beware that if your function performs some illegal operation that
raises an error, the protected function will catch the error and return it
as a string. This is because the <span style="font-weight: bold; font-style: italic;">try</span> function
uses errors as the mechanism to throw exceptions.  
</p>


<h4><a name="snmp_newtry"></a>result = snmp.newtry(FINALIZER)</h4>


<p class="description">
Creates and returns a <em>clean <span style="font-weight: bold;">try</span>&nbsp;</em>function that allows for cleanup before the exception 
is  raised.&nbsp; 
</p>




<p class="parameters"> 
<span style="font-weight: bold;">FINALIZER</span> is a function that will be called before
<tt>try</tt> throws the exception. It will be called 
in <em>protected</em> mode.
</p>




<p class="return"> 
The function <span style="font-weight: bold; font-style: italic;">snmp.newtry</span> returns your customized <tt>try</tt> function.</p>


<p class="return">Example:</p>


<pre>local snmp = require "snmp"<br />local mib = snmp.mib<br /><br />--<br />-- We need this reference here for the finalizer<br />--<br />local sess<br /><br />--<br />-- Finalize function<br />--<br />local function finalize()<br />  io.write("Cleanup handler: ")<br />  if sess then<br />    if rawget(sess, "internal") then<br />      print("closing session.")<br />      sess:close()<br />    else<br />      print("session already closed.")<br />    end<br />  else<br />    print("nothing to do.")<br />  end<br />end<br /><br />local function pdoit()<br /><br />  -- <br />  -- Acquire a new exception handler<br />  --<br />  local try = snmp.newtry(finalize)<br /><br />  --<br />  -- Do some work: no failure here<br />  --<br />  sess = try(snmp.open{peer = "goofy"})<br />  <br />  --<br />  -- Do some work: no failure here<br />  --<br />  local vl = try(sess:get{"sysContact.0","sysDescr.0"})<br />  table.foreach(vl, print)<br /><br />  --<br />  -- Do some work: no failure here<br />  --<br />  local vl = try(snmp.walk(sess, "ifDescr"))<br />  table.foreach(vl, print)<br /><br />  --<br />  -- Do some work: no failure here<br />  --<br />  local t = try(sess.ifDescr)<br />  for k,v in snmp.spairs(t) do print(k,v) end<br /><br />  --<br />  -- Close the session orderly. Note this will delete the<br />  -- internal session. Following usage must fail.<br />  --<br />  try(sess:close())<br /><br />  --<br />  -- Try to re-use the old session which should fail<br />  --<br />  local vl = try(snmp.walk(sess, "ifDescr"))<br />  table.foreach(vl, print)<br /><br />  return "ok"<br />end<br /><br />--<br />-- Execute the protected function 'pdoit'<br />--<br />local rv, err = snmp.protect(pdoit)()<br /><br />-- <br />-- Evaluate the result of error capturing<br />--<br />if not rv then<br />  print("doit error: '"..(err or "unknown").."'")<br />else<br />  print("doit o.k.")<br />end<br /></pre>


<h4><a name="snmp_try"></a>result = snmp.try(RET1 [, RET2, ..., RETn])</h4>


<p>Throws an exception in case of an error in <span style="font-weight: bold;">RET1</span>. The exception can only be caught 
by the function <a href="#snmp_protect"><span style="font-weight: bold; font-style: italic;">snmp.protect</span></a>. If used outside a protected function, the Lua script is abortet WITHOUT error message or stack backtrace.&nbsp;
</p>




<p class="parameters">
<tt></tt>The function receives an arbitrary number of arguments <span style="font-weight: bold;">RET1</span> to <span style="font-weight: bold;">RETn</span>, which are typically the returns values of a function call nested with snmp.try. The function returns <span style="font-weight: bold;">RET1</span> to <span style="font-weight: bold;">RETn</span> if <span style="font-weight: bold;">RET1</span> was not nil. Otherwise, it calls <span style="font-weight: bold; font-style: italic;">error</span> passing <span style="font-weight: bold;">RET2</span> as argument. 
</p>




<h2><a name="misc_func"></a>Miscellaneous Functions</h2>











<h4><a name="snmp_check"></a>result = snmp.check(EXPRESSION, MESSAGE])</h4>











<p>The function <span style="font-weight: bold; font-style: italic;">snmp.check</span>
performs a check on the result of LuaSNMP functions. It works similar
to the standard Lua function assert. However, instead of just checking <span style="font-weight: bold;">EXPRESSION</span>, snmp.check also checks whether <span style="font-weight: bold;">MESSAGE</span> is nil. It returns the given <span style="font-weight: bold;">EXPRESSION</span> only if the following two conditions are met: <span style="font-weight: bold; font-style: italic;">EXPRESSION == true and MESSAGE == nil</span>.</p>











<p>The function is provided for convenience reasons, because there are
conditions, where LuaSNMP will return both, a valid result AND an error
message. For these cases Lua's standard <span style="font-weight: bold; font-style: italic;">assert</span> function is not suited to capture errors by simply writing result = assert(FUNCTION).</p>











<p>Using assert:</p>











<pre>-- NOTE: DOES NOT WORK PROPERLY IN ALL CASES<br />vbind, err = assert(session:get(OBJECT))<br /><br />-- NOTE: THIS WORKS<br />vbind, err = session:get(OBJECT)<br />assert(vbind and not err, err)</pre>











<p>Using check:</p>











<pre>-- Do this once in the script<br />local check = snmp.check<br />...<br />-- NOTE: WORKS<br />vbind, err = check(session:get(OBJECT))<br />vbind, err = session:get(OBJECT)<br />check(vbind, err)<br /><br />-- NOTE: DOES NOT WORK, because MESSAGE will be always non-nil <br />vbind, err = session:get(OBJECT)<br />check(vbind, "Error occured here")</pre>











<p>Note, that you MUST NOT specify your own error message to
snmp.check, because this will always lead to an error condition (see
example above).</p>














<h4><a name="snmp_getkeys"></a>keys = snmp.getkeys(TABLE)</h4>














<p>Retrieves a table with keys from a table, that has been created via <a href="#snmp_object_access">SNMP Object Access</a>. The keys are lexicographically sorted.</p>














<p>Example:</p>














<pre>local snmp = require "snmp"<br /><br />-- Open the session<br />local hub, err = assert(snmp.open{peer="localhost"})<br /><br />-- Get a table or part of a table<br />local ifDescr = hub.ifDescr<br /><br />local keys = snmp.getkeys(ifDescr)<br /><br />-- Print using standard iterator<br />print("Using standard iterator:")<br />for k,v in pairs(ifDescr) do<br />  print(string.format("%s = %s", k, v))<br />end<br /><br />-- Print using sorting iterator<br />print("Using sorting iterator:")<br />for i,key in ipairs(keys) do<br />  print(string.format("%s = %s", key, ifDescr[key]))<br />end</pre>














<p>See <a href="#snmp_spairs">snmp.spairs&nbsp;</a> for an output of this script.</p>














<h4><a name="snmp_spairs"></a>key, value = snmp.spairs(TABLE)</h4>














<p>The iterator <span style="font-weight: bold; font-style: italic;">snmp.spairs</span> works similar to the standard Lua operator
pairs. However, instead of returning the elements of a table with
arbitrary keys in arbitrary order&nbsp; (e.g. table as created via <a href="#snmp_object_access">SNMP Object Access</a>), it returns the elements in a lexicographically sorted order of their keys.</p>














<pre>local snmp = require "snmp"<br /><br />-- Let's have a local reference to this function<br />local spairs = snmp.spairs<br /><br />-- Open the session<br />local hub, err = assert(snmp.open{peer="localhost"})<br /><br />-- Get a table or part of a table<br />local ifDescr = hub.ifDescr<br /><br />-- Print using standard iterator<br />print("Using standard iterator:")<br />for k,v in pairs(ifDescr) do<br />  print(string.format("%s = %s", k, v))<br />end<br /><br />-- Print using sorting iterator<br />print("Using sorting iterator:")<br />for k,v in spairs(ifDescr) do<br />  print(string.format("%s = %s", k, v))<br />end<br /><br /></pre>














<p>The script above produces the following output:</p>














<pre>Using standard iterator:<br />ifDescr.3 = eth1<br />ifDescr.2 = eth0<br />ifDescr.4 = eth2<br />ifDescr.5 = sit0<br />ifDescr.1 = lo<br />Using sorting iterator:<br />ifDescr.1 = lo<br />ifDescr.2 = eth0<br />ifDescr.3 = eth1<br />ifDescr.4 = eth2<br />ifDescr.5 = sit0<br /></pre>









<h4><a name="snmp_instance"></a>oid = snmp.instance(ARG1, ARG2, ..., ARGN)<br />









oid = mib.instance(ARG1, ARG2, ..., ARGN)</h4>









<p>Creates an oid instance substring from arguments ARG1 to ARGN. Each
argument is converted into OID syntax. Single arguments are separated
by a period '.'. Lua types are processed in the following way:</p>









<ul>









  <li>number values &nbsp;are directly converted to a single node within the OID.</li>









  <li>string values are analysed whether the string contains an OID.
If yes, the function returns that OID prepended by period '.'.
Otherwise the string is encoded using the function <a style="font-weight: bold; font-style: italic;" href="#snmp_stringoid">snmp.stringoid</a>. The length of the string is prepended as single node.</li>









  <li>boolean values are encoded as single node, where false is encoded as 0 and true is encoded as 1</li>









  <li>tables are accepted and recursively interpreted as argument
extension (via Lua <span style="font-style: italic;">unpack&nbsp;</span>function), where each value&nbsp; in the
table represents a new argument.</li>









</ul>









<p>Example:</p>









<pre>luasnmp$ lua -l snmp -i<br />&gt; =snmp.instance(99,"hello",true,{99,"hello",true})<br />.99.5.104.101.108.108.111.1.99.5.104.101.108.108.111.1<br />&gt; =snmp.instance{1,2,3,4,5}<br />.1.2.3.4.5<br /></pre>







<h4><a name="snmp_stringoid"></a>oid = snmp.stringoid(STR)</h4>







<p>Converts a string into an OID. &nbsp;The function works similar as
snmp.instance with a string as argument. The only differences is that
snmp.stringoid produces an absolute OID &nbsp;(without a leading '.'),
while snmp.instance always prepends a leading dot.&nbsp;</p>







<h1><a name="snmp_object_access"></a>SNMP Object Access</h1>




















<p>LuaSNMP provides a simplified&nbsp;access method to SNMP instances,
where the object instances appear as members of an SNMP session. The
method usese the Lua metamethods <span style="font-weight: bold;">__index</span> and <span style="font-weight: bold;">__newindex</span>
attached to a&nbsp;session. Once a session has been successfully
created, each read access to a session member is automatically
translated to a read accesses to&nbsp;SNMP object instances with the
given name. Also, any attempt to assign a value to a member is&nbsp;
translated to a write request to the given SNMP instances.&nbsp;</p>

















<p>The above works for single SNMP object instances and also
for&nbsp;tables containing multiple object instances. Tables are always
returned as simple Lua tables, where the key always represents a valid
object identifier in symbolic notation and index instances appended.
The values behave like values of <a href="objects.html#varbinds">varbinds</a>.
A returned table can be handled in two different ways. You can assign
new values to table entries and then assign assign the table as value
to the session member or you can use the indices of the table as single
member names for assignment.</p>

















<p>here are a few aspects to consider if you want to use this simplified way of SNMP programming.</p>

















<ul>

















  <li>If you use the form SESSION.instance any dot '.' in the instance name must be replaced with an underscore, e.g. <span style="font-weight: bold;">hub1.sysContact_0</span>. LuaSNMP will translate any underscored instance name into a dotted instance name.<br />

















Note, that the underscore is not required if the access occurs using the form <span style="font-weight: bold;">hub1["sysContact.0"]</span></li>

















  <li>Direct object accesses do not return any type information. SNMP
types are sliently translated into Lua types and vice versa. However,
you don't have to care during write access. LuaSNMP will always use the
correct type when writing to object instances.</li>

















  <li>If you retrieve a complete table, the table indices cannot be
expected to be sorted. However, it is easy to create a sorted table
using Lua's <span style="font-weight: bold; font-style: italic;">table.sort&nbsp;</span> function</li>

















</ul>

















<p>Example script:</p>

















<pre>local snmp = require "snmp"<br /><br />hub1 = assert(snmp.open{peer = "goofy", community = "private"})<br /><br />-- Sets an re-stores sysContact.0<br />local oldval = hub1.sysContact_0<br />print("sysContact.0 = " .. hub1.sysContact_0)<br /><br />hub1.sysContact_0 = "admin"<br />print("sysContact.0 = " .. hub1["sysContact.0"])<br /><br />hub1["sysContact.0"] = oldval<br />print("sysContact.0 = " .. hub1.sysContact_0)<br /><br />-- Shows the list of interface names<br />itab = hub1.ifName<br />table.foreach(itab, print)<br /><br />-- Counts the number of objects in mib-2.<br />local mib2 = hub1["mib-2"]<br />sum = 0<br />for _,v in pairs(mib2) do<br />  sum = sum + 1<br />end<br />print("Number of entries in 'mib-2': " .. sum)</pre>

















<p>The above script produces the following output:</p>

















<pre>luasnmp$ lua doc/examples/direct.lua<br />sysContact.0 = root<br />sysContact.0 = admin<br />sysContact.0 = root<br />ifName.1        lo<br />ifName.2        eth0<br />ifName.5        sit0<br />ifName.3        eth1<br />ifName.4        eth2<br />Number of entries in 'mib-2': 2389</pre>

















</div>

























<div id="footer">(c) 2006-2009 Herbert Leuwer, March 2006&nbsp;&nbsp; &nbsp;<a href="mailto:herbert.leuwer@t-online.de">Contact</a></div>

























<small><small>
</small></small>
</body>
</html>
